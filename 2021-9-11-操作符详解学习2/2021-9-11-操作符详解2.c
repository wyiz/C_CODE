#define _CRT_SECURE_NO_WARNINGS 1
#pragma warning(disable:6031)



//单目操作符

/*

! 逻辑反操作
- 负值
+ 正值
& 取地址
sizeof 操作数的类型长度（以字节为单位）
~ 对一个数的二进制按位取反
-- 前置、后置--
++ 前置、后置++
* 间接访问操作符(解引用操作符)
(类型) 强制类型转换

*/



//  int a = 10;    这里a是数组名。除变量名之外的是变量的是变量类型  int  是变量a的类型

// int arr[10] = { 0 };  这里arr是数组名，除数组名之外的是数组的类型   int []   是数组arr的类型




//关系操作符

/*

>
>=
<
<=
!= 用于测试“不相等”
== 用于测试“相等”

*/




//逻辑操作符
 
//逻辑操作符是用来判断真假的

// && 逻辑与   意思是并且   同时为真才为真，有一个为假则为假
// || 逻辑或   意思是或者


//区分逻辑与和按位与 区分逻辑或和按位或
 
//    1 & 2----->0
//    1 && 2---- > 1
//    1 | 2----->3
//    1 || 2---- > 1




//360笔试题

/*
#include <stdio.h>
int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	//i = a++||++b||d++;
	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
	return 0;
}
//程序输出的结果是什么？    1 2 3 4

*/

//程序分析：

//做这道题目之前需要知道：int c = a && b;  当 a 为假的时候，此时 b 就不用算了


//i = a++ && ++b && d++;   

// a++ 是一个后置++ ，此时a的值为0  ，那么后面的表达式就不需要再进行计算了  所以计算结果是 1 2 3 4 


//如果将上面代码改成 //i = a++||++b||d++;

//计算结果是 1 3 3 4






//条件操作符

//   exp1 ? exp2 : exp3

//exp1 ? exp2 : exp3
/*

1.
if (a > 5)
b = 3;
else
b = -3;
转换成条件表达式，是什么样？


2.使用条件表达式实现找两个数中较大值


*/



//1

/*

#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d",&a);

	b = (a > 5 ? 3 : -3);

	printf("%d ",b);



	return 0;
}

*/


//2.

/*

#include <stdio.h>

int main()
{
	int a = 10;
	int b = 20;
	int c = 0;
	
	c = a > b ? a : b;

	printf("%d", c);


	return 0;
}

*/





//逗号表达式

//exp1, exp2, exp3, …expN

//逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果





//下标引用、函数调用和结构成员

//1.[ ] 下标引用操作符
//操作数：一个数组名 + 一个索引值

/*

int arr[10];//创建数组
arr[9] = 10;//实用下标引用操作符。
[ ]的两个操作数是arr和9。

*/


//2.( ) 函数调用操作符 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数


//3.访问一个结构的成员

//  .  结构体.成员名
//  -> 结构体指针->成员名

/*
#include <stdio.h>
struct Stu
{
	char name[10];
	int age;
	char sex[5];
	double score;
}；

void set_age1(struct Stu stu)
{
	stu.age = 18;
}
void set_age2(struct Stu* pStu)
{
	pStu->age = 18;//结构成员访问
}
int main()
{
	struct Stu stu;
	struct Stu* pStu = &stu;//结构成员访问
	stu.age = 20;//结构成员访问
	set_age1(stu);
	pStu->age = 20;//结构成员访问
	set_age2(pStu);
	return 0;
}

*/





//表达式求值

//表达式求值的顺序一部分是由操作符的优先级和结合性决定。同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型


//隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。

//整型提升的意义：

//表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度

//通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转
//换为int或unsigned int，然后才能送入CPU去执行运算

/*

//实例1
char a,b,c;
...
a = b + c;

*/

//b和c的值被提升为普通整型，然后再执行加法运算。
//加法运算完成之后，结果将被截断，然后再存储于a中


//如何进行整体提升呢？
//整形提升是按照变量的数据类型的符号位来提升的


/*
#include <stdio.h>

int main()
{
	char a = 3;
	//a的二进制位：00000000000000000000000000000011        因为这是32位操作系统
	//因为a是char类型，只能存放8个bit位，所以
	//a中存放的数据为：00000011      （最高位是符号位 0   ，代表的是正数）

	char b = 127;
	// b的二进制位：00000000000000000000000001111111
	//b中实际存放的数据：01111111     （最高位是符号位 0   ，代表的是正数）


	char c = a + b;
	//发现a和b都是char类型的，都没有达到一个int的大小，这里就会发生整型提升
	
	//根据上面整型提升的规则：整形提升是按照变量的数据类型的符号位来提升的
	//a整型提升之后：00000000000000000000000000000011
	//b整型提升之后：00000000000000000000000001111111
	//c整型提升之后：00000000000000000000000010000010

	//c中实际存放的数据：10000010

	printf("%d ",c);
	//这里打印数据的类型是：%d   是整型  ，但是c的类型是char类型
	//所以打印c的时候，也需要进行整型提升

	//c中存放的数据为：10000010    （最高位是符号位）
	//按照整型提升的规则：整形提升是按照变量的数据类型的符号位来提升的

	//c进行整型提升之后：11111111111111111111111110000010     （这是内存中存放的数据，是以补码的形式进行打印的）
	//要想在屏幕上进行打印，需要将补码还原成原码

	//正数的原反补相同，
	//只有负数才需要进行原反补的计算，  其中，符号位不变

	//c的补码：11111111111111111111111110000010
	//c的反码：11111111111111111111111110000001
	//c的原码：10000000000000000000000001111110
	
	//所以最后打印的结果是-126


	return 0;
}

*/





/*

       //负数的整形提升

          char c1 = -1;
          变量c1的二进制位(补码)中只有8个比特位：1111111
          因为 char 为有符号的 char
          所以整形提升的时候，高位补充符号位，即为1
          提升之后的结果是：11111111111111111111111111111111




	   //正数的整形提升
          char c2 = 1;
          变量c2的二进制位(补码)中只有8个比特位：00000001
          因为 char 为有符号的 char
          所以整形提升的时候，高位补充符号位，即为0
          提升之后的结果是：00000000000000000000000000000001



       //无符号整形提升，高位补0



*/



//整形提升的例子:

//实例1

/*
#include<stdio.h>
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)        //因为a是char类型，进行整型提升之后就不在是0xb6
		printf("a");
	if (b == 0xb600)      //同理，b进行整型提升之后，就不再是0xb600
		printf("b");
	if (c == 0xb6000000)   //因为c本身就是整型，不需要进行整型提升，故打印的结果是c
		printf("c");        //最后的打印结果是 c  
	return 0;
}


*/


//实例2

/*


#include<stdio.h>
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c));
	printf("%u\n", sizeof(+c));
	printf("%u\n", sizeof(!c));
	return 0;
}


//计算结果是：1 4 4 


*/



//实例2中的,c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字节.
//表达式 - c 也会发生整形提升, 所以 sizeof(-c) 是4个字节, 但是 sizeof(c), 就是1个字节

//因为上面的程序中：+ -  ！都参与了运算，只要运算，就会发生整型提升




//操作符的属性

//复杂表达式的求值有三个影响的因素：

//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序

//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性


